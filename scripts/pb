#!/usr/bin/env bash
set -euo pipefail

VERSION="0.1.0"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(dirname "$SCRIPT_DIR")"
STATE_DIR="$PROJECT_DIR/.powerblockade"
STATE_FILE="$STATE_DIR/state.json"
BACKUP_DIR="$PROJECT_DIR/backups"
COMPOSE_CMD="docker compose"

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log_info() { echo -e "${BLUE}[INFO]${NC} $*"; }
log_success() { echo -e "${GREEN}[OK]${NC} $*"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $*"; }
log_error() { echo -e "${RED}[ERROR]${NC} $*" >&2; }

ensure_dirs() {
    mkdir -p "$STATE_DIR" "$BACKUP_DIR"
}

get_current_version() {
    if [[ -f "$STATE_FILE" ]]; then
        jq -r '.current_version // "unknown"' "$STATE_FILE" 2>/dev/null || echo "unknown"
    else
        echo "unknown"
    fi
}

get_compose_files() {
    local files="-f compose.yaml"
    if [[ -f "$PROJECT_DIR/compose.user.yaml" ]]; then
        files="$files -f compose.user.yaml"
    elif [[ -f "$PROJECT_DIR/docker-compose.yml" ]]; then
        files="-f docker-compose.yml"
    fi
    echo "$files"
}

check_docker() {
    if ! command -v docker &>/dev/null; then
        log_error "Docker not found. Please install Docker first."
        exit 1
    fi
    if ! docker info &>/dev/null; then
        log_error "Docker daemon not running or insufficient permissions."
        exit 1
    fi
}

check_disk_space() {
    local required_mb=500
    local available_mb
    available_mb=$(df -m "$PROJECT_DIR" | awk 'NR==2 {print $4}')
    if [[ "$available_mb" -lt "$required_mb" ]]; then
        log_error "Insufficient disk space. Need ${required_mb}MB, have ${available_mb}MB."
        exit 1
    fi
}

get_image_digests() {
    local digests="{}"
    for service in admin-ui dnstap-processor sync-agent; do
        local digest
        digest=$(docker inspect --format='{{index .RepoDigests 0}}' "powerblockade-$service" 2>/dev/null | cut -d@ -f2 || echo "")
        if [[ -n "$digest" ]]; then
            digests=$(echo "$digests" | jq --arg s "$service" --arg d "$digest" '. + {($s): $d}')
        fi
    done
    echo "$digests"
}

backup_database() {
    local timestamp
    timestamp=$(date +%Y%m%d-%H%M%S)
    local backup_file="$BACKUP_DIR/pre-upgrade-$timestamp.sql"
    
    log_info "Backing up database to $backup_file..."
    
    cd "$PROJECT_DIR"
    local compose_files
    compose_files=$(get_compose_files)
    
    if $COMPOSE_CMD $compose_files exec -T postgres pg_dump -U powerblockade powerblockade > "$backup_file" 2>/dev/null; then
        log_success "Database backup complete: $backup_file"
        echo "$backup_file"
    else
        log_warn "Database backup failed (postgres may not be running)"
        echo ""
    fi
}

backup_config() {
    local timestamp
    timestamp=$(date +%Y%m%d-%H%M%S)
    local backup_file="$BACKUP_DIR/config-$timestamp.tar.gz"
    
    log_info "Backing up config files..."
    
    cd "$PROJECT_DIR"
    local files_to_backup=""
    [[ -d shared/rpz ]] && files_to_backup="$files_to_backup shared/rpz"
    [[ -d shared/forward-zones ]] && files_to_backup="$files_to_backup shared/forward-zones"
    [[ -f .env ]] && files_to_backup="$files_to_backup .env"
    
    if [[ -n "$files_to_backup" ]]; then
        tar -czf "$backup_file" $files_to_backup 2>/dev/null || true
        log_success "Config backup complete: $backup_file"
        echo "$backup_file"
    else
        echo ""
    fi
}

save_state() {
    local version="$1"
    local prev_version="$2"
    local prev_digests="$3"
    local db_backup="$4"
    local config_backup="$5"
    
    cat > "$STATE_FILE" <<EOF
{
    "current_version": "$version",
    "previous_version": "$prev_version",
    "previous_image_digests": $prev_digests,
    "last_db_backup": "$db_backup",
    "last_config_backup": "$config_backup",
    "upgrade_timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
}
EOF
}

run_migrations() {
    log_info "Running database migrations..."
    cd "$PROJECT_DIR"
    local compose_files
    compose_files=$(get_compose_files)
    
    if $COMPOSE_CMD $compose_files run --rm admin-ui alembic upgrade head; then
        log_success "Migrations complete"
        return 0
    else
        log_error "Migration failed!"
        return 1
    fi
}

verify_health() {
    log_info "Verifying service health..."
    
    local max_wait=60
    local waited=0
    
    while [[ $waited -lt $max_wait ]]; do
        if curl -sf http://localhost:8080/health &>/dev/null; then
            log_success "Admin UI healthy"
            break
        fi
        sleep 2
        waited=$((waited + 2))
    done
    
    if [[ $waited -ge $max_wait ]]; then
        log_warn "Admin UI health check timed out"
    fi
    
    if command -v dig &>/dev/null; then
        if dig @127.0.0.1 example.com +short +time=5 &>/dev/null; then
            log_success "DNS resolution working"
        else
            log_warn "DNS resolution test failed"
        fi
    fi
}

cmd_version() {
    echo "pb version $VERSION"
    echo ""
    echo "PowerBlockade version: $(get_current_version)"
}

cmd_status() {
    echo "PowerBlockade Status"
    echo "===================="
    echo ""
    echo "Version: $(get_current_version)"
    echo ""
    
    cd "$PROJECT_DIR"
    local compose_files
    compose_files=$(get_compose_files)
    
    echo "Services:"
    $COMPOSE_CMD $compose_files ps --format "table {{.Name}}\t{{.Status}}\t{{.Ports}}" 2>/dev/null || echo "  (unable to get service status)"
    echo ""
    
    if [[ -f "$STATE_FILE" ]]; then
        echo "Last upgrade: $(jq -r '.upgrade_timestamp // "never"' "$STATE_FILE")"
        echo "Previous version: $(jq -r '.previous_version // "none"' "$STATE_FILE")"
    fi
}

cmd_check_update() {
    log_info "Checking for updates..."
    
    local current
    current=$(get_current_version)
    
    local latest
    latest=$(curl -sf "https://api.github.com/repos/powerblockade/powerblockade/releases/latest" 2>/dev/null | jq -r '.tag_name // empty' | sed 's/^v//' || echo "")
    
    if [[ -z "$latest" ]]; then
        log_warn "Unable to check for updates (GitHub API unavailable or repo not configured)"
        return 1
    fi
    
    echo ""
    echo "Current version: $current"
    echo "Latest version:  $latest"
    echo ""
    
    if [[ "$current" == "$latest" ]]; then
        log_success "You are running the latest version"
    else
        log_info "Update available! Run 'pb update' to upgrade"
    fi
}

cmd_update() {
    local target_version=""
    local skip_backup=false
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --to)
                target_version="$2"
                shift 2
                ;;
            --skip-backup)
                skip_backup=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    ensure_dirs
    check_docker
    check_disk_space
    
    cd "$PROJECT_DIR"
    local compose_files
    compose_files=$(get_compose_files)
    
    local current_version
    current_version=$(get_current_version)
    local prev_digests
    prev_digests=$(get_image_digests)
    
    echo ""
    echo "PowerBlockade Update"
    echo "===================="
    echo ""
    echo "Current version: $current_version"
    [[ -n "$target_version" ]] && echo "Target version:  $target_version"
    echo ""
    
    local db_backup=""
    local config_backup=""
    
    if [[ "$skip_backup" != true ]]; then
        db_backup=$(backup_database)
        config_backup=$(backup_config)
        echo ""
    fi
    
    log_info "Pulling latest images..."
    if ! $COMPOSE_CMD $compose_files pull; then
        log_error "Failed to pull images"
        exit 1
    fi
    log_success "Images pulled"
    echo ""
    
    if ! run_migrations; then
        log_error "Migration failed. Aborting update."
        log_error "Your services have NOT been restarted."
        log_error "Database backup: $db_backup"
        exit 1
    fi
    echo ""
    
    log_info "Restarting services..."
    $COMPOSE_CMD $compose_files up -d admin-ui
    sleep 2
    $COMPOSE_CMD $compose_files up -d
    log_success "Services restarted"
    echo ""
    
    verify_health
    echo ""
    
    local new_version
    new_version=$(curl -sf http://localhost:8080/api/version 2>/dev/null | jq -r '.version // "unknown"' || echo "unknown")
    
    save_state "$new_version" "$current_version" "$prev_digests" "$db_backup" "$config_backup"
    
    log_success "Update complete!"
    echo ""
    echo "New version: $new_version"
    [[ -n "$db_backup" ]] && echo "Backup: $db_backup"
}

cmd_rollback() {
    local restore_db=true
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --fast)
                restore_db=false
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    if [[ ! -f "$STATE_FILE" ]]; then
        log_error "No upgrade state found. Cannot rollback."
        exit 1
    fi
    
    local prev_version
    prev_version=$(jq -r '.previous_version // empty' "$STATE_FILE")
    local db_backup
    db_backup=$(jq -r '.last_db_backup // empty' "$STATE_FILE")
    
    if [[ -z "$prev_version" || "$prev_version" == "null" ]]; then
        log_error "No previous version recorded. Cannot rollback."
        exit 1
    fi
    
    echo ""
    echo "PowerBlockade Rollback"
    echo "======================"
    echo ""
    echo "Rolling back to: $prev_version"
    [[ "$restore_db" == true ]] && echo "Database restore: yes"
    [[ "$restore_db" == false ]] && echo "Database restore: no (--fast mode)"
    echo ""
    
    read -p "Continue? [y/N] " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Rollback cancelled."
        exit 0
    fi
    
    cd "$PROJECT_DIR"
    local compose_files
    compose_files=$(get_compose_files)
    
    log_info "Stopping services..."
    $COMPOSE_CMD $compose_files down
    
    if [[ "$restore_db" == true && -n "$db_backup" && -f "$db_backup" ]]; then
        log_info "Restoring database from $db_backup..."
        $COMPOSE_CMD $compose_files up -d postgres
        sleep 5
        
        $COMPOSE_CMD $compose_files exec -T postgres psql -U powerblockade -c "DROP SCHEMA public CASCADE; CREATE SCHEMA public;" powerblockade 2>/dev/null || true
        $COMPOSE_CMD $compose_files exec -T postgres psql -U powerblockade powerblockade < "$db_backup"
        log_success "Database restored"
    fi
    
    log_info "Starting services with previous images..."
    $COMPOSE_CMD $compose_files up -d
    
    verify_health
    
    log_success "Rollback complete!"
    echo ""
    log_warn "Note: You may need to manually pull the correct image versions if using :latest tags."
    log_warn "For deterministic rollback, use versioned tags (e.g., v0.2.0) instead of :latest."
}

cmd_backup() {
    ensure_dirs
    check_docker
    
    local db_backup
    db_backup=$(backup_database)
    local config_backup
    config_backup=$(backup_config)
    
    echo ""
    log_success "Backup complete!"
    [[ -n "$db_backup" ]] && echo "Database: $db_backup"
    [[ -n "$config_backup" ]] && echo "Config: $config_backup"
}

cmd_help() {
    cat <<EOF
pb - PowerBlockade management CLI

Usage: pb <command> [options]

Commands:
    status          Show current status and version
    check-update    Check for available updates
    update          Update to latest version
    rollback        Rollback to previous version
    backup          Create database and config backup
    version         Show CLI version
    help            Show this help

Update Options:
    --to VERSION    Update to specific version
    --skip-backup   Skip pre-upgrade backup (not recommended)

Rollback Options:
    --fast          Skip database restore (only safe if schema is N-1 compatible)

Examples:
    pb status
    pb check-update
    pb update
    pb update --to 0.3.0
    pb rollback
    pb rollback --fast
    pb backup

EOF
}

main() {
    local cmd="${1:-help}"
    shift || true
    
    case "$cmd" in
        status)
            cmd_status
            ;;
        check-update)
            cmd_check_update
            ;;
        update)
            cmd_update "$@"
            ;;
        rollback)
            cmd_rollback "$@"
            ;;
        backup)
            cmd_backup
            ;;
        version|-v|--version)
            cmd_version
            ;;
        help|-h|--help)
            cmd_help
            ;;
        *)
            log_error "Unknown command: $cmd"
            cmd_help
            exit 1
            ;;
    esac
}

main "$@"
