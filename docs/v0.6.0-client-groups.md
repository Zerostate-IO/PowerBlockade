# v0.6.0: Per-Client-Group Blocklist Enforcement

## Overview

Allow different client groups to have different blocklists applied. For example:
- "Kids" group → strict blocklists (ads, adult, social media)
- "Adults" group → basic blocklists (ads only)
- "IoT" group → no blocklists (devices need full access)

## Current State (v0.4.0)

- `client_groups` table exists with CIDR-based auto-assignment
- `clients.group_id` foreign key exists
- UI for groups management exists but is hidden (not functional)

## Implementation Plan

### 1. Database Schema

Already have `client_groups` table. Need to add:

```sql
CREATE TABLE group_blocklists (
    group_id INTEGER REFERENCES client_groups(id) ON DELETE CASCADE,
    blocklist_id BIGINT REFERENCES blocklists(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    PRIMARY KEY (group_id, blocklist_id)
);
```

### 2. Admin UI Changes

1. Re-enable `/clients/groups` page
2. Add blocklist selection to group edit form
3. Show which blocklists apply to each group
4. "Apply" button regenerates all RPZ zones

### 3. RPZ Zone Generation

When "Apply" is clicked:

1. Generate `blocklist-combined.rpz` (default, all enabled blocklists)
2. For each group with custom blocklists:
   - Generate `group-{id}.rpz` containing only that group's blocklists
3. Generate `client-groups.json` mapping:
   ```json
   {
     "groups": [
       {"id": 1, "name": "Kids", "cidrs": ["192.168.10.0/24"]},
       {"id": 2, "name": "IoT", "cidrs": ["192.168.20.0/24"]}
     ],
     "clients": {
       "192.168.1.50": 1,
       "192.168.1.51": 2
     }
   }
   ```

### 4. Lua Policy Changes

Replace current `rpz.lua` with dynamic policy:

```lua
-- Load client-group mapping
local json = require("dkjson")
local mapping = {}

function reloadMapping()
    local f = io.open("/etc/pdns-recursor/rpz/client-groups.json", "r")
    if f then
        mapping = json.decode(f:read("*all"))
        f:close()
    end
end

reloadMapping()

-- Check which group a client belongs to
function getClientGroup(ip)
    -- Check explicit client mapping first
    if mapping.clients and mapping.clients[ip] then
        return mapping.clients[ip]
    end
    -- Check CIDR ranges
    for _, group in ipairs(mapping.groups or {}) do
        for _, cidr in ipairs(group.cidrs or {}) do
            if ipInCIDR(ip, cidr) then
                return group.id
            end
        end
    end
    return nil -- No group, use default
end

-- Load all RPZ zones
rpzFile("/etc/pdns-recursor/rpz/blocklist-combined.rpz", {
    policyName = "default"
})
rpzFile("/etc/pdns-recursor/rpz/whitelist.rpz", {
    policyName = "whitelist",
    defpol = Policy.PASSTHRU
})

-- Per-group zones (loaded but not applied by default)
local groupZones = {}
-- Dynamically load group-*.rpz files

function preresolve(dq)
    local clientIP = dq.remoteaddr:toString()
    local groupId = getClientGroup(clientIP)
    
    if groupId and groupZones[groupId] then
        -- Apply group-specific policy
        return groupZones[groupId]:apply(dq)
    end
    
    -- Default: apply standard RPZ
    return false
end
```

### 5. Dependencies

- Need `dkjson` Lua library in recursor container (or use custom parser)
- Or: generate Lua table directly instead of JSON

### 6. Testing

1. Create "Strict" group with all blocklists
2. Create "Permissive" group with no blocklists
3. Assign test clients to each group
4. Verify blocked domains differ per client

## Complexity Estimate

- Database + UI: 2 hours
- RPZ generation: 2 hours  
- Lua policy: 3-4 hours (most complex)
- Testing: 1-2 hours

**Total: ~8-10 hours**

## Alternative: Simpler Approach

Instead of Lua hooks, use multiple recursor instances:
- `recursor-default` on port 5300 (all blocklists)
- `recursor-kids` on port 5301 (strict blocklists)
- `recursor-iot` on port 5302 (no blocklists)

dnsdist routes clients to appropriate recursor based on IP.

Pros: Simpler, no Lua complexity
Cons: More memory usage, more containers to manage

## Decision

TBD - evaluate both approaches when implementing v0.6.0.
